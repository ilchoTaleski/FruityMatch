<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="richTextBox1.Text" xml:space="preserve">
    <value>One player makes a code by combining different fruits, and the other player tries to guess the code
in as few tries as possible.
To play, one player secretly places a number of pegs at the top of the board; those pegs are then hidden. The
other player then makes a guess by placing pegs on the Master Match board. The results of the guess are
then shown.
The blue Correct Place &amp; Color result tells you which pegs are the correct color and are in the correct place,
whereas the white Correct Color result tells you which pegs are the correct color but are not in the correct
place. This information helps you make an educated guess at the code in future turns.
Normally, each peg in the secret code is a different color; for a more challenging game, uncheck the No
Duplicates option in the game options. Note that regardless of this setting, you can use two or more pegs of
the same color when you guess.
Master Match Guess Example
In the example below, your first guess (on the bottom row) gives a match result of 1 | 2. This tells you that one
peg is the correct color and is in the correct place, and two pegs are the correct color, but are not in the correct
place.
For your second guess, the match result of 0 | 2 tells you that two of the pegs are the correct color, but none
of the pegs are in the correct place.
You learn at least two things from the combination of these two results:
Although you used three of the same colors of pegs in your first and second guess, in your second guess, only
two pegs were the correct color (three were correct in the first guess). So you know that yellow (the only color
you omitted) is definitely in the puzzle, and the new color, purple, is definitely not in the puzzle.
Although you left white in the same place in each guess, the result for Correct Place &amp; Color changed from 1
to 0 (nothing), so you know that white is definitely not in the correct place. 
For your next guess, you should add a yellow peg to your guess, and you might want to try guessing
white in a different place. Note that although you know yellow’s in the puzzle, you don’t know which of the other
colors in your first guess is correct or incorrect.
Playing Master Match
To play:
1 If necessary, create a code for the other player by moving pegs to the board. Then click the Submit
Puzzle button.
There are three ways to move pegs to the board: Drag
each peg to the appropriate peg hole. Click a peg in a
peg tray and then click a hole.
Right-click (Ctrl+click on the Macintosh) on one of the peg trays to automatically move a peg of that color to
the next available peg hole.
You can move a peg by dragging it from one peg hold to another. To remove a peg from the board, rightclick
the peg, or drag it away from the current row.
2 On each turn, make a guess by moving pegs to the board (as described above). For your first guess, use the
bottom row. For each subsequent guess, move up one row.
You must place a peg in each hole.
3 W hen you’ve made your guess, click the Match button next to your guess to see how you did.
4 Continue guessing until you guess the code or run out of guesses (you run out when you fill every row on the
Master Match board). If you’re playing the two-board non-scoring version, the game also ends
if the other player guesses your code.
Master Match Versions
You can play Master Match with one or two boards.
In the standard two-board version, there are two Master Match boards, and each player makes a code for the
other player to guess. Then, you and the other player simultaneously try to guess each others’ codes.
In the one-board version, you play with one Master Match board. If you’re playing with a computer player, that
player makes a code for you, and you try to guess it. If you’re playing with a human player, you take turns making
and guessing codes. 
</value>
  </data>
</root>